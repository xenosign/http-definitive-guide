# 16. 국제화 (Internationalization)

- HTTP는 전 세계에서 사용되므로, 서버는 각 사용자의 지역과 언어에 맞는 콘텐츠를 제공할 수 있어야 한다.
- 이번 장에서는 캐릭터 셋(Character Set), 언어 태그(Language Tags), 그리고 이를 기반으로 최적의 리소스를 선택하는 과정을 다룬다.

## 16.1 HTTP 캐릭터 셋과 엔코딩

- 전 세계의 다양한 글자를 비트(0과 1)로 변환하고 해석하는 방식은 국제화의 가장 기초적인 단계이다.
- 캐릭터 셋(Character Set): 문자를 고유한 숫자로 매핑한 것 (예: 유니코드의 코드 포인트).
- 인코딩(Encoding): 캐릭터 셋의 숫자를 실제 전송 가능한 비트로 변환하는 방식 (예: UTF-8, UTF-16).

### 16.1.1 차셋(Charset)은 비트-문자 매핑이다

- HTTP `charset` 값은 수신자가 비트 열을 어떤 방식으로 해석해 문자로 복원할지 결정한다.
- 잘못된 `charset`을 사용하면 글자가 깨지는 현상이 발생한다.

### 16.1.2 MIME 차셋의 역사와 UTF-8

- 과거엔 `ISO-8859-1` 같은 지역별 8비트 인코딩이 쓰였으나, 현재는 거의 모든 문자를 표현할 수 있는 UTF-8이 사실상 표준이다.

### 16.1.3 Content-Type charset 매개변수와 META 태그

- HTTP 헤더의 `Content-Type`에서 charset을 지정할 수 있다.

```http
Content-Type: text/html; charset=UTF-8
```

- HTML 문서 내에서도 `<meta>` 태그로 charset을 명시할 수 있다.

```html
<meta charset="UTF-8" />
```

- HTTP 헤더의 charset이 HTML meta 태그보다 우선순위가 높다.

### 16.1.4 Accept-Charset 헤더

- 클라이언트는 `Accept-Charset` 헤더를 통해 자신이 지원하는 문자 인코딩을 서버에 알릴 수 있다.

```http
Accept-Charset: UTF-8, ISO-8859-1;q=0.7
```

- 서버는 이 정보를 참고하여 적절한 charset으로 응답할 수 있다.
- 실무에서는 대부분의 브라우저가 UTF-8을 기본으로 지원하므로 이 헤더는 자주 사용되지 않는다.

## 16.2 Content-Language: 대상 관객의 언어

- `Content-Language` 헤더는 엔터티 본문이 어떤 자연어(Natural Language)로 작성되었는지를 명시한다.
- 이는 기술적 포맷보다는 "누가 이 문서를 읽을 수 있는가"에 초점을 맞춘다.

```http
Content-Language: ko, en
```

### 16.2.1 언어 태그

- 언어 태그는 RFC 5646에 정의되어 있으며, 언어와 지역을 조합하여 표현한다.
- 형식: `언어코드-지역코드` (예: `ko-KR`, `en-US`, `zh-CN`)
- 언어코드만 사용할 수도 있다 (예: `ko`, `en`)

### 16.2.2 서브태그

- 언어 태그는 여러 서브태그로 구성될 수 있다.
- 주 언어 태그: 필수 요소로, ISO 639 언어 코드 사용 (예: `ko`, `en`, `zh`)
- 지역 서브태그: ISO 3166 국가 코드 사용 (예: `KR`, `US`, `CN`)
- 스크립트 서브태그: 문자 체계 지정 (예: `zh-Hans`, `zh-Hant`)

### 16.2.3 대소문자 구별과 표현

- 언어 태그는 대소문자를 구별하지 않는다.
- 관례상 언어 코드는 소문자, 국가 코드는 대문자로 표기한다.

### 16.2.4 Accept-Language 헤더

- 클라이언트는 `Accept-Language` 헤더로 선호하는 언어를 서버에 알린다.

```http
Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8, en;q=0.7
```

- `q` 값(품질 지수)은 0.0~1.0 사이의 값으로, 선호도를 나타낸다.
- 서버는 이 정보를 바탕으로 적절한 언어 버전의 콘텐츠를 제공한다.

## 16.3 국제화된 URI

- URI에도 ASCII가 아닌 문자를 포함할 수 있어야 한다.
- 하지만 URI는 기본적으로 US-ASCII 문자 집합만을 허용한다.

### 16.3.1 국제 문자를 이스케이핑

- 비ASCII 문자는 퍼센트 인코딩(Percent Encoding)을 사용하여 표현한다.
- UTF-8로 인코딩된 바이트를 `%XX` 형식으로 변환한다.

```
예시: "한글" -> %ED%95%9C%EA%B8%80
```

### 16.3.2 국제화된 도메인 이름(IDN)

- 도메인 이름에도 각국 언어의 문자를 사용할 수 있다.
- Punycode를 사용하여 유니코드 도메인을 ASCII로 변환한다.
- 예시: `한국.kr` -> `xn--3e0b707e.kr`

## 16.4 기타 고려사항

### 16.4.1 헤더와 명세

- HTTP/1.1은 헤더 필드 이름이 US-ASCII여야 한다고 명시한다.
- 헤더 필드 값도 ISO-8859-1 범위 내의 문자만 허용하지만, RFC 2047 인코딩을 사용할 수 있다.

### 16.4.2 날짜와 통화

- 날짜 형식은 지역마다 다르므로 ISO 8601 표준을 따르는 것이 좋다.
- 통화 기호와 금액 표기도 지역에 따라 달라지므로 주의가 필요하다.
- ISO 4217 통화 코드를 사용하면 명확하다 (예: `KRW`, `USD`, `EUR`)

### 16.4.3 서버 주도 협상

- 서버는 클라이언트의 `Accept-Language`, `Accept-Charset` 등의 헤더를 분석하여 최적의 표현을 선택한다.
- 서버가 요청된 언어나 문자셋을 지원하지 못하면 기본값을 제공하거나 406(Not Acceptable) 응답을 반환한다.

### 16.4.4 에이전트 주도 협상

- 서버가 사용 가능한 모든 버전의 목록을 제공하고, 클라이언트가 선택하는 방식이다.
- 300(Multiple Choices) 응답을 사용할 수 있다.

### 16.4.5 투명 협상

- 서버 주도와 에이전트 주도 협상의 장점을 결합한 방식이다.
- 중간 프록시가 협상을 대신 수행할 수 있다.

## 16.5 정리

- HTTP는 국제화를 위해 문자 인코딩, 언어 태그, URI 인코딩 등 다양한 메커니즘을 제공한다.
- 현대 웹 개발에서는 UTF-8과 표준 언어 태그를 사용하는 것이 권장된다.
- 클라이언트와 서버 간의 협상을 통해 사용자에게 최적의 언어와 형식으로 콘텐츠를 제공할 수 있다.
- 국제화는 단순히 번역을 넘어 날짜, 통화, 문화적 관습까지 고려해야 하는 포괄적인 작업이다.
