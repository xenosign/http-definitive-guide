# 15. 엔터티와 인코딩

- HTTP 는 메시지를 올바르게 수성, 식별, 추출, 처리 되는 것을 보장하기 위해 잘 라벨링된 엔터티를 사용하며 이번 장에서는 아래의 내용을 다룬다
- HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 포맷과 동작 방식
- 어떻게 HTTP 가 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP 가 무엇을 요구하는지
- 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들
- 공간을 적제 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는, 디코딩 가능한 인코딩
- 특정 종류의 콘텐츠의 송수신을 개선하기 위해 HTTP 가 데이터를 실어 나르는 방식을 수정하는 전송 인코딩, 그 중에서도 콘텐츠의 안정적 전송을 위해 쪼개서 전당하는 청크 인코딩
- 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬의 모음
- 콘텐츠의 버전 번호처럼 동작하는 검사기들과 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드들
- 중단 되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
- 클라리언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그 때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
- 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는, 엔터티 본문의 체크섬

## 15.1 메시지는 컨테이터, 언터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적 화물
- HTTP/1.1 은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의
  - Content-Type : 객체의 종류
  - Content-Length : 메시지의 길이나 크기
  - Content-Language : 객체와 잘 대응되는 자연어
  - Content-Encoding : 객체에 대해 행해진 변형
  - Content-Location : 요청 시점을 기준, 객체의 또 다른 위치
  - Content-Range : 엔터티가 어떤 엔터티의 부분이라면, 전체 부분에서 어느 부분에 해당하는지
  - Content-Md5 : 엔터티 본문 콘텐츠에 대한 체크섬
  - Last-Modified : 서버에서 콘텐츠가 생성 혹은 마지막으로 수정 된 날
  - Expries : 엔터티 데이터가 신선하지 않다고 간주되기 시작하는 날짜와 시각
  - Allow : 리소스에 대해 허용되는 메서드
  - ETag : 이 객체의 버전에 대한 고유한 검사기
  - Cache-Control : 이 문서가 어떻게 캐시 될 수 있는지에 대한 지시자

> ETag 추가 설명
> - 스펙 상 ETag 는 `강한 검사기(strong ETag)` 와 `약한 검사기(weak ETag, W/"..." 형태)` 로 나뉘며, 전자는 바이트 단위로 동일할 때만 같다고 보고, 후자는 의미상 동등할 때 같다고 처리

### 15.1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있기에, 엔터티 헤더에는 데이터의 의미에 대해 설명이 필요
- 엔터티 본문은 헤더 필드이 끝을 의미하는 빈 줄(CRLF) 다음 부터 시작

![img.png](images/15_entity_encoding_01.png)

## 15.2 Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지 엔터티 본문의 크기를 인코딩에 상관 없이 바이트 단위로 표기
- 메시지를 청크로 보내는 것이 아닌 이상, 전송 된 메시지가 완전한지 파악하기 위한 필수 헤더 값

### 15.2.1 잘림 검출

- 과거 HTTP 는 커넥션을 기준으로 메시지가 끝났음을 파악했지만, 현재는 메시지 잘림이나 서버 충돌의 가능성 때문에 Content-Length 를 기반으로 확인
- 캐싱 프락시 서버에서 잘린 메시지를 인식하지 못하면 캐시는 결함이 있는 콘텐츠를 계속해서 제공하는 문제 발생 가능

### 15.2.2 잘못된 Content-Length

- Content-Length 가 잘못된 값을 전달하는 경우 아예 없는 것보다 큰 피해 유발이 가능

### 15.2.3 Content-Length 와 지속 커넥션(Persistent Connection)

- 지속 커넥션은 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식할 수 없어 Content-Length 가 필수

### 15.2.4 콘텐츠 인코딩

- 콘텐츠 인코딩이 되어있다면 Content-Length 는 원본이 아닌 인코딩 된 본문의 길이를 바이트 단위로 전달
- 잘못된 어플리케이션은 원분의 크기를 보내는 경우가 있는데 이는 심각한 오류를 유발

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문이 없어야 하는 타입(HEAD 요청 등)의 메시지에는 Content-Length 가 무시되며, 부가 정보 정도로만 사용
2. 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면 엔터티는 `0 바이트 청크` 로 끝나야 한다
3. Content-Length 가 있는 경우 Transfer-Encoding 헤더가 존재하지 않는 이상 해당 헤더는 본문의 길이를 담게 된다
4. 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 Content-Length 로 길이가 정의되지 않았다면, 해당 유형은 스스로 크기를 정의할 수 있는 유일한 유형
5. 위의 규칙에 해당되지 않는다면 엔터티는 커넥션이 닫힐 때 끝난다
6. HTTP/1.0 과의 호환을 위해 엔터티 본문이 있는 HTTP/1.1 은 유효한 Content-Length 를 가져야 한다. 유효한 Content-Length 를 요구하고 싶다면 411 Length Required 응답을 보내면 된다

## 15.3 엔터티 요약

- HTTP 상에서 메시지의 일부분이 전송 중에 변형되는 일이 발생
- 엔터티에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 데이터에 대한 체크섬을 생성할 수 있으며 수신자는 기본적으로 체크섬 검사를 수행한다
- `Content-MD5` 헤더는 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용되며, 중간에 있는 프락시와 캐시는 `Content-MD5` 헤더를 변경하거나 추가하면 안되며 추가할 경우 종단 간 무결성이 훼손

## 15.4 미디어 타입과 차셋(Charset)

- `Content-Type` 헤더는 엔터티 본문의 MIME 타입을 기술하며, MIME 타입은 전달되는 매체의 기저 형식(HTML, 워드 문서, 비디오 등)을 알려준다
- MIME 는 IANA(Internet Assigned Numbers Authority)에 의해 표준화 된 매체 타입의 이름

![img.png](images/15_entity_encoding_02.png)

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- `Content-Type` 헤더는 내용 유형을 더 자세히 지정하기 위한 매개 변수를 지원하며, charset 이 대표정

```http
Content-Type: text/html; charset=iso-8859-4
```

### 15.4.2 멀티파트 미디어 타입

- MIME 의 `멀티파트` 메세지는 서로 붙어있는 여러 개의 메시지를 포함하는 복합 메세지로 전송

### 15.4.3 멀티파트 폼 제출

- HTTP 폼을 제출하면 가변 길이 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 부분으로 전송
- boundary 는 본문의 서로 다른 부분을 구분하기 위한 구분자로 사용

```http
Content-Type: multipart/form-data; boundary=[adjakldjaklda]
```

![img.png](images/15_entity_encoding_03.png)

- 위의 폼 양식에서 텍스트 필드에 "Sally", 파일로 "essayfile.txt" 를 선택한 경우의 요청

![img.png](images/15_entity_encoding_04.png)

- 사용자가 이미지 파일인 "imagefile.gif" 를 추가한 경우

![img.png](images/15_entity_encoding_05.png)

### 15.4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있으며, `Content-Type: multipart/byteranges` 헤더 및 각각의 `boundary` 값을 포함해서 전달

## 15.5 콘텐츠 인코딩

- HTTP 어플리케이션은 콘텐츠를 보내기 전에 압축, 암호화 또는 별도의 목적을 이유로 인코딩해서 전송이 가능 

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type 과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성
2. 콘텐츠 인코딩 서버(원 서버 or 프락시)가 메시지를 인코딩하여 인코딩 메시지 생성하며, `Content-Encoding` 헤더를 추가. 인코딩에 의해 엔터티 길이가 변하지만 디코딩 시 원본의 길이는 유지되므로 Content-Length 는 변경 X
3. 수신 측은 인코딩 된 메시지를 받아서 디코딩

![img.png](images/15_entity_encoding_06.png)

### 15.5.2 콘텐츠 인코딩 유형

- HTTP 는 몇 가지 표준 인코딩 유형을 정의하고 확장 인코딩 추가를 허용

![img.png](images/15_entity_encoding_07.png)

### 15.5.3 Accept-Encoding 헤더

- 클라이언트가 자신이 지원하는 인코딩의 목록을 전달하기 위해 사용하는 헤더, 해당 내용이 없을 경우 어떤 인코딩이든 받아 들일 수 있는 것으로 간주
- Q(quality) 매개 변수 값(0 ~ 1) 를 통해 선호도 전달도 가능

```http
GET /logo.gif HTTP/1.1
Accept-encoding: gzip;q=1.0, *;q=0.1
```

## 15.6 전송 인코딩과 청크 인코딩

- 전송 인코딩은 엔터티에만 인코딩이 적용되는 콘텐츠 인코딩과는 달리 전체 메시지에 대해 적용되며, 메시지 자체의 구조를 바꾼다. 구조적인 이유에 의해 사용

![img.png](images/15_entity_encoding_08.png)

### 15.6.1 안전한 전송

- 전송 인코딩은 다른 프로토콜을 사용하는 네트워크를 통하여 '안전한 전송'을 구현하기 위해 존재

#### 알 수 없는 크기
- 몇몇 게이트웨이 어플리케이션과 콘텐츠 인코더는 본문의 최종 크기를 판단할 수 없기에, HTTP 에서 요구하는 Content-Length 를 보낼 수 는 상황이 발생
- 이 때, 데이터 끝을 알리는 특별한 종결 꼬리말을 포함하는 전송 인코딩으로 방법을 우회

#### 보안
- 보안이 확실하지 않은 네트워크를 사용하는 경우 콘텐츠를 뒤섞어 보내는 전송 인코딩 사용이 가능하지만, 네트워크 자체가 안전한 SSL 사용이 더 빈번

### 15.6.2 Transfer-Encoding 헤더

#### Transfer-Encoding
- 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 알려주는 헤더

#### TE
- 어떤 확장된 전송 인코딩을 사용할 수 있는지 확인하기 위해 서버에 보내는 헤더

```http
GET /gg.html HTTP/1.1
Host: gg.com
User-Agent: Mozilla/4.61
TE: trailers, chunked
```

### 15.6.3 청크 인코딩

- 메시지를 일정 크기의 청크로 쪼개서 순차적으로 보내는 방법. 전체 크기를 알 필요 없이 본문을 동적 생성이 가능하며, 버퍼 활용이 가능

#### 청크와 지속 커넥션
- 지속 커넥션의 경우 Content-Length 를 기반으로 통신을 결정하지만, 청크 커넥션은 커넥션의 유지 시간으로 결정
- 마지막 청크임을 확인하기 위해 길이가 0 인 CRLF 문자열을 전달

![img.png](images/15_entity_encoding_09.png)

#### 청크 인코딩 된 메시지의 트레일러
- 트레일러는 본문의 콘텐츠가 먼저 생성되어야 한다는 이유로 메시지 시작 시점에 그 값을 알기 어려운 추가적 헤더 필드를 담아서 전송 (Ex. Content-MD5 헤더)

### 15.6.4 콘텐츠와 전송 인코딩의 조합

- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용이 가능

![img.png](images/15_entity_encoding_10.png)

### 15.6.5 전송 인코딩 규칙

- 전송 인코딩 방식의 집합에는 반드시 `chunked` 가 포함, 유일한 예외는 메시지가 커넥션 종료로 끝나는 경우
- 어떠한 HTTP/1.1 어플리케이션이라도 최소한 청크 인코딩 방식은 지원해야 함

## 15.7 시간에 따라 바뀌는 인스턴스

- 웹 객체가 자주 변경되는 케이스의 경우 객체의 다른 버전을 인스턴스라 칭하며, 클라이언트는 자신이 가지고 있는 리소스의 사본이 서버가 가지고 있는 것과 같은지 판단하고 새 인스턴스를 요청할 수 있어야 한다

![img.png](images/15_entity_encoding_11.png)

## 15.8 검사기와 신선도

### 15.8.1 신선도

- 서버는 Expires, Cache-Control 헤더를 통해 전달되는 사본의 신선도에 대한 정보를 전달이 가능

![img.png](images/15_entity_encoding_12.png)

### 15.8.2 조건부 요청과 검사기

- HTTP 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 방법이 존재하며, `If` 로 시작하는 조건부 헤더에 의해 구현
- 검사기의 경우 리소스의 인스턴스를 완번히 고유하게 식별하는 강한 검사기(체크섬, ETag 등) 와 그러지 못하는 약한 검사기(Expires 의 시간 등)가 존재
- 서버가 캐시의 재검사로 인한 대량 트래픽을 유발하고 싶지 않으면서 신선도에 대한 처리를 하고 싶을 때에는 `W/` 를 붙여서 약한 검사기임을 알릴 수 있다

```http
GET /gg.html HTTP/1.1
If-Modified-Since: Sat, 20 Jum 2004, 14:30:00 GMT
```

![img.png](images/15_entity_encoding_13.png)


## 15.9 범위 요청

- HTTP 는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 범위 요청을 제공

![img.png](images/15_entity_encoding_14.png)

- 위와 같이 클라이언트가 4000 Byte 만 받고 연결이 끊겼을 경우, 4000 Byte 이후의 데이터만 범위 요청이 가능
- 단, 모든 서버가 범위 요청을 받아들일 수 있는지 알 수 없으므로 `Accept-Ranges: bytes` 같은 헤더를 통해 클라이언트에게 가능한 범위 요청의 종류를 알려줄 수 있다

![img.png](images/15_entity_encoding_15.png)

## 15.10 델타 인코딩

- 델타 인코딩은 HTTP 프로토콜의 확장으로 특정 리소스에 대해 변경된 부분만을 보내서 전송량을 최적화하는 방법
- 클라이언트와 서버는 리소스에 대한 버전을 통해 만료 여부를 확인 후, 델타 인코딩을 받아들일 의사에 대한 확인 후 델타를 계산하여 통신

![img.png](images/15_entity_encoding_16.png)

- 아래는 델타 인코딩에 사용되는 헤더 모음

![img.png](images/15_entity_encoding_17.png)

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- 델타 인코딩을 통해 리소스의 변경된 부분을 계산하는 인스턴스 조작의 종류는 아래와 같다

![img.png](images/15_entity_encoding_18.png)

- 델타 인코딩은 전송 시간을 줄일 수 있지만
  - 변경 부분을 계산하는 것의 복잡성과 서버 과부화 문제
  - 클라이언트가 가진 사본과 현재 버전 문서의 차이를 서버에서 계산해야 하기 때문에 이전 버전의 문서를 서버 내부에 가지고 있어야 하는 문제가 존재

> 델타 인코딩의 이야기를 보면서 이건 요즘 안쓰겠다 싶었는데,
> - 델타 인코딩의 개념(변경 된 것만 전송 및 저장)은 사실상 git 의 근본 개념으로 사용
> - HTTP/2, HTTP/3 에서 반복되는 헤더로 인한 트래픽 증가를 막기 위해 헤더의 차이점만을 전송하는 HPACK(HTTP/2), QPACK(HTTP/3) 에 사용