# 12. 기본 인증

- 웹은 편리함을 제공하지만 특정 문서 혹은 데이터는 권한에 따라 접근이 달라져야 하므로, HTTP 는 자체적인 인증 관련 기능을 제공

## 12.1 인증

- 인증은 당신이 누구인지 증명하는 것
- 완벽한 인증이란 없으며, 비밀번호는 추측하거나 해킹이 가능하며 신분증은 위조되거나 도둑 맞을 수 있다

### 12.1.1 HTTP 의 인증 요구 / 응답 프레임워크

- HTTP 는 기본적으로 사용자 인증을 하는 데 자체 인증 요구 / 응답 프레임워크를 제공

![img.png](images/12_basic_authentication_01.png)

- 웹 서버가 HTTP 요청 메시지를 받으면 서버는 요청을 처리하는 대신 사용자가 누구인지 식별하기 위한 '인증 요구'로 응답할 수 있다
- 해당 '인증 요구' 에 적절한 인증 정보를 첨부하지 못할 경우 서버는 해당 응답을 거부

### 12.1.2 인증 프로토콜과 헤더

- HTTP 는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 각기 다른 인증 프로코톨에 맞추어 확장할 수 있는 프레임워크를 제공
- HTTP 는 기본 인증과 다이제스트 인증이라는 2 가지 공식 인증 프로토콜을 제공하며, 다이제스트 인증은 13장에서 다룬다

|  단계   |          헤더          | 설명                                                                                    | 메서드/상태           |
|:-----:|:--------------------:|:--------------------------------------------------------------------------------------|:-----------------|
|  요청   |                      | 첫 번째 요청, 인증 정보 X                                                                      | GET              |
| 인증 요구 |   WWW-Authenticate   | 서버는 사용자 식별을 위해 적절한 인증을 요구하면서 401 상태 코드와 요청을 반려, 서버에서 요구하는 인증은 WWW-Authenticate 헤더에 기술 | 401 Unauthorized |
|  인증   |    Authorization     | 클라이언트는 서버의 인증 요구에 맞추어 Authorization 헤더를 작성하여 요청을 다시 보낸다                               | GET              |
|  성공   | Authentication-info  | 인증이 성공하면, 서버는 요청한 응답을 전송. 추가 적인 인증 세션 정보는 Authentication-info 에 담아서 전달                | 200 OK           |

![img.png](images/12_basic_authentication_02.png)

### 12.1.3 보안 영역

- 서버에 존재하는 리소스에 따라 상이한 접근 조건이 있는 경우에는 `보안 영역(realm)` 그룹으로 나누어 관리
- 아래는 재무 영역과 가족 영역으로 나뉜 realm 과 그에 따른 HTTP 응답 예시

```http
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

![img.png](images/12_basic_authentication_03.png)

## 12.2 기본 인증

- 기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호 요구 가능
- 서버는 WWW-Authenticate 헤더에 필요한 인증 정보를 요청하고, 클라이언트는 이에 맞는 인증 정보를 Authorization 헤더 안에 암호화 해서 서버로 보내는 방식

### 12.2.1 기본 인증의 예

- 서버의 인증 요구 응답

```http
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="보안 영역의 이름"
```

- 클라이언트의 인증 정보를 담은 요청


```http
GET /corporate/financials/sales-forecast.xls HTTP/1.0
Authorization: Basic base-62로 인코딩한 사용자 이름과 비밀번호
```

### 12.2.2 Base-64 사용자 이름 / 비밀번호 인코딩

- HTTP 기본 인증은 사용자 이름과 비밀번호를 `:` 으로 이어서 합치고 base-64 로 인코딩 하여 전달
- base-64 는 바이너리, 텍스트, 국제 문자 데이터 등 시스템에서 문제를 일으킬 수 있는 문자열을 알파벳으로 변환하기 위해 개발
- HTTP 기본 인증에서는 헤더에서 사용할 수 없는 문자(큰따옴표, 콜론, 캐리지 리턴 등)를 알파벳으로 변환하기 위해서, 그리고 비밀번호가 쉽게 노출 되는 문제를 예방하기 위해 사용

![img.png](images/12_basic_authentication_04.png)

> Base64 작동 원리
> - 64개의 안전한 문자(a ~ Z, 0 ~ 9, +, /)와 길이를 채우기 위한 패딩 문자(=)로만 인코딩
> - 원본 데이터에 구조에 상관 없이 3byte(= 24bit) 단위로 데이터를 잘라서 가져온 뒤, 각각 6bit 씩 4개로 자름
> - 잘려진 4개의 6bit(= 최대 64의 값을 저장) 는 데이터의 값에 따라 Base64 에서 사용하는 64개의 문자 중 하나로 매핑되어 인코딩
> - 결과적으로 3byte 의 원본데이터가 4개의 문자로 인코딩 되므로 4개 x 1byte = 4byte 가 되어 33%의 용량이 증가
> - 원본의 마지막 데이터 길이가 3byte 의 배수가 아닌 경우 패딩 문자(=)를 사용하여 빈 공간을 채움
> - 암호화는 아니므로 누구나 디코딩이 가능, 목적에 맞게 사용이 필요

### 12.2.3 프락시 인증

- 특정 상황의 경우 서버에 접근하기 전, 중개 프락시 서버를 통해 인증을 처리
- 특정 서버 전체에 대한 접근 자체를 관리하는 경우에는 유용
- HTTP 헤더와 응답코드는 기본 인증과 동일

## 12.3 기본 인증의 보안 결함

- 기본 인증은 단순하고 편리하지만 보안적 결함이 있으므로, SSL 과 같은 암호 기술과 혼용
- 기본 인증의 보안적 결함
  - base-64 인코딩의 경우 누구나 디코딩을 할 수 있는 문제
  - 암호화 하여 정보를 전달하여도 제 3자가 해당 값을 볼 수 있으므로, 값을 탈취하여 악용 가능
  - 인증 헤더 이외에 부분을 수정하여 악의적 공격 가능
  - 악의적 가짜 서버의 위장에 취약
- 위오와 같은 문제를 해결하기 위해 HTTP 요청 자체를 암호화 해서 보내는 SSL 과 연계에서 사용하는 것이 보편 적

> 현대 웹에서의 보안 접근
> - 현대 욉은 '통신 채널'과 '인증 정보'를 둘 다 개선하여 보안을 처리
> - 통신 채널의 경우 HTTPS 를 사용하여 통신 자체를 암호화
> - 인증 정보의 경우 JWT 를 사용, 정보 자체를 암호화 하여 전달
> - 또한 해당 쿠키의 경우 HttpOnly, Secure 속성을 사용하여 통신 시에만 사용이 가능하며 JS 로 접근이 불가능 하도록 하여 XSS 공격 자체를 무효화