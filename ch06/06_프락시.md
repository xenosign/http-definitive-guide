# 06. 프락시

- HTTP 프락시와 웹 게이트웨이를 비교하고 HTTP 프락시가 어떻게 배치 되는지
- 몇 가지 유용한 활용 방법
- 프락시가 실제 네트워크에 어떻게 배치되어 있는지 그리고 트래픽이 어떻게 프락시 서버로 가는지
- 브라우저에게 프락시를 사용하려면 어떻게 설정해야 하는지
- HTTP 프락시 요청이 서버 요청과 어떻게 다른지, 그리고 프락시가 어떻게 브라우저의 동작을 미묘하게 바꾸는지
- 일련의 프락시 서버들을 통과하는 메시지의 경로를 Via 헤더와 TRACE 메서드를 이용해 기록하는 방법
- 프락시에 기반한 HTTP 접근 제어 설명
- 어떻게 프락시가 클라이언트와 서버 사이에서 각각의 다른 기능과 버전들을 지원하면서 상호 작용 하는지
 
## 6.1 웹 중계자

- 웹 프락시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인
- 프락시가 없다면 클라이언트는 서버와 직접 이야기하지만, 있다면 클라이언트는 자신의 입장에서 서버와 대화해주는 프락시와 이야기 한다
- 프랜잭션을 완료하는 것은 결국 클라이언트지만, 프락시 서버가 제공하는 좋은 서비스 이용이 가능
- 프락시는 서버이면서 동시에 클라이언트의 입장을 가진다

![img.png](images/06_proxy_01.png)

### 6.1.1 개인 프락시와 공유 프락시

#### 공용 프락시
- 대부분의 크락시는 공용이며 공유된 프락시이며, 여러 사용자가 공통된 요청에서 이득을 취할 수 있기 때문에 사용자가 많을 수록 유리하다

#### 개인 프락시
- 주로 클라이언트 컴퓨터에서 직접 실행되는 형태로 사용되며, ISP(Internet Service Provider) 서비스 등을 위해서 사용 된다

### 6.1.2 프락시 vs 게이트웨이

- 프락시는 같은 프로토콜을 사용하는 어플리케이션을 연결, 게이트웨이는 서로 다른 프로토콜을 연결

![img.png](images/06_proxy_02.png)

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버는 보안 개선 / 성능 개선 / 비용 절약 등의 유용한 일을 한다
- 프락시 서버는 모든 HTTP 트래픽에 관여할 수 있기 때문에 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현 가능

#### 어린이 필터
- 어린이들에게 성인 컨텐츠를 차단하는 필터링 프락시

![img.png](images/06_proxy_03.png)

#### 문서 접근 제어자
- 웹 서버와 리소스에 대한 접근 제어를 중앙 프락시 서버를 통해 구현

![img.png](images/06_proxy_04.png)

#### 보안 방화벽
- 프락시 서버가 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 프락시 서버를 통해 한 지점에서 통제 가능

![img.png](images/06_proxy_05.png)

> 프락시를 통한 방화벽 개념과 서브넷을 활용한 물리적 분리 비교

> | 구분        | 프록시 서버를 통한 보안                       | 퍼블릭/프라이빗 서브넷 전략 (VPC)            |
> |:----------|:------------------------------------|:---------------------------------|
> | 주요 보호 계층  | 애플리케이션 계층 (L7)                      | 네트워크 계층 (L3/L4)                  |
> | 작동 위치     | 클라이언트와 서버 사이의 중개자                   | 클라우드 내 논리적 네트워크 경계               |
> | 보안 목표     | HTTP/HTTPS 요청 콘텐츠 검사 및 필터링, 익명성 제공  | 민감 자원(DB)의 인터넷 노출 원천 차단 및 격리     |
> | 주요 위협 대응  | 웹 애플리케이션 공격 (SQL 인젝션, XSS, 봇 트래픽)   | 무단 IP 접근, 포트 스캐닝, 인프라 침투         |
> | 보호 대상     | 요청/응답 데이터의 내용                       | 내부 서버의 IP 주소와 존재 자체              |
> | 예시 컴포넌트   | 리버스 프록시 (Nginx), WAF (웹 방화벽)        | VPC, 보안 그룹, 라우팅 테이블, NAT 게이트웨이   |

#### 웹 캐시
- 프락시 캐시는 인기 있는 문서의 로컬 사본을 관리하고, 해당 문서에 대한 요청을 빠르게 제공

![img.png](images/06_proxy_06.png)

> 웹 캐시와 CDN 의 차

> | 구분         | 웹 캐시 프록시 (Web Cache Proxy)          | CDN (Content Delivery Network)  |
> |:-----------|:------------------------------------|:--------------------------------|
> | **설치 목적**  | **네트워크 대역폭 절약** 및 내부망 접근 속도 개선      | 최종 사용자에게 **지연 시간(Latency) 최소화** |
> | **주요 사용자** | **내부 네트워크**의 클라이언트 그룹 (회사, ISP 가입자) | 전 세계 모든 **최종 사용자**              |
> | **위치/제어**  | 클라이언트 측 (사용 조직/ISP가 제어)             | 서버 측 (콘텐츠 제공자가 제어)              |
> | **캐시 방향**  | **Outbound** (외부 리소스를 내부망으로 당겨옴)    | **Inbound** (콘텐츠를 사용자에게 제공)     |
> | **분산 정도**  | 보통 **단일 지점** 또는 지역적                 | 전 세계 **수많은 엣지 서버(POP)**에 분산     |
> | **트래픽 절감** | 외부망으로 나가는 트래픽 비용 절감                 | 원본 서버(Origin)의 부하 절감            |

#### 대리 프락시(Surrogate)
- 웹 서버인 것 처럼 위장하는 기능을 통해 리버스 프락시라고 불리우며, 실제 웹 서버 요청을 받지만 요청 받은 컨텐츠의 처리는 다른 서버와 커뮤니케이션을 통해 처리 한다

> 포워드 프락시 vs 리버스 프록시 <br>
> 포워드 프록시 : 클라이언트(사용자)를 대신하여 외부에 요청. 내부망의 노출을 막고, 특정 사이트의에 대한 접근 제어, 캐싱을 통해 성능 개선 등을 목적
> 리버스 프록시 : 서버를 대신하여 클라이언트의 요청을 받음. 보안, 로드 밸런싱, 캐싱 등 서버 보호와 성능 최적화 목적 사용

```shell
# Upstream (백엔드 서버 그룹 정의)
upstream backend_servers {    
    # 로드 밸런싱 정책: 기본값 Round-Robin
    # weight=n: 가중치 설정 (이 서버가 n배 더 많은 트래픽 처리)
    # max_fails=3, fail_timeout=30s: 30초 동안 3번 실패하면 잠시 트래픽에서 제외
    server 192.168.1.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.1.11:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 192.168.1.12:8081;
}

# HTTP (80 포트) 설정: HTTPS로 강제 리다이렉션
server {
    listen 80;
    server_name www.우리가 사용할 도메인.com;
    
    # 301 Moved Permanently 코드로 모든 HTTP 요청을 HTTPS로 전환
    return 301 https://$host$request_uri;
}

# HTTPS (443 포트) 설정: SSL 종료 및 로드 밸런싱
server {
    # 443 포트로 수신하며 SSL/TLS 사용을 명시
    listen 443 ssl http2;
    server_name www.우리가 사용할 도메인.com;

    # 인증서 파일과 키를 통한 SSL/TLS 설정    
    ssl_certificate /etc/nginx/ssl/your_domain.crt;
    ssl_certificate_key /etc/nginx/ssl/your_domain.key;
    
    # 보안 강화를 위한 권장 프로토콜 및 암호화 설정
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5:!kEDH;
    ssl_prefer_server_ciphers on;    
    
    # 모든 요청(루트 요청, /)에 대한 프록시 설정
    location / {
        # upstream backend_servers 로 정의된 로드 밸런싱 그룹으로 전달
        proxy_pass http://backend_servers;

        # 필수 헤더 설정, 클라이언트의 실제 IP 주소 전달
        proxy_set_header X-Real-IP $remote_addr; 
        # 최초 요청 호스트명 전달
        proxy_set_header Host $host; 
        # NGINX가 SSL을 종료했음을 백엔드에 알림
        proxy_set_header X-Forwarded-Proto $scheme; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Nginx 서버와 실제 어플리케이션 서버 사이의 내부 커넥션 유지 설정
        proxy_http_version 1.1; 
        proxy_set_header Connection ""; # 커넥션 헤더를 제거하여 내부 커넥션 재사용 유도
    }
}
```

#### 콘텐츠 라우터
- 트래픽의 조건과 콘텐츠의 종류에 따라 상황에 맞는 웹 서버로 트래픽을 유도하는 콘텐츠 라우터로 동작 가능

![img.png](images/06_proxy_07.png)

#### 트랜스코더
- 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정하는 프락시 서버
- 용량이 큰 이미지 포맷을 작은 이미지로 변환, 텍스트 압축, 언어 변환 등의 기능 제공

![img.png](images/06_proxy_08.png)

#### 익명화 프락시(Anonymizer)
- HTTP 메시지에서 신원을 특정할 수 있는 특성(IP 주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디 등)을 제거하여 익명성을 보장해 주는 프락시

![img.png](images/06_proxy_09.png)