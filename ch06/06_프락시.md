# 06. 프락시

- HTTP 프락시와 웹 게이트웨이를 비교하고 HTTP 프락시가 어떻게 배치 되는지
- 몇 가지 유용한 활용 방법
- 프락시가 실제 네트워크에 어떻게 배치되어 있는지 그리고 트래픽이 어떻게 프락시 서버로 가는지
- 브라우저에게 프락시를 사용하려면 어떻게 설정해야 하는지
- HTTP 프락시 요청이 서버 요청과 어떻게 다른지, 그리고 프락시가 어떻게 브라우저의 동작을 미묘하게 바꾸는지
- 일련의 프락시 서버들을 통과하는 메시지의 경로를 Via 헤더와 TRACE 메서드를 이용해 기록하는 방법
- 프락시에 기반한 HTTP 접근 제어 설명
- 어떻게 프락시가 클라이언트와 서버 사이에서 각각의 다른 기능과 버전들을 지원하면서 상호 작용 하는지
 
## 6.1 웹 중계자

- 웹 프락시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인
- 프락시가 없다면 클라이언트는 서버와 직접 이야기하지만, 있다면 클라이언트는 자신의 입장에서 서버와 대화해주는 프락시와 이야기 한다
- 프랜잭션을 완료하는 것은 결국 클라이언트지만, 프락시 서버가 제공하는 좋은 서비스 이용이 가능
- 프락시는 서버이면서 동시에 클라이언트의 입장을 가진다

![img.png](images/06_proxy_01.png)

### 6.1.1 개인 프락시와 공유 프락시

#### 공용 프락시
- 대부분의 크락시는 공용이며 공유된 프락시이며, 여러 사용자가 공통된 요청에서 이득을 취할 수 있기 때문에 사용자가 많을 수록 유리하다

#### 개인 프락시
- 주로 클라이언트 컴퓨터에서 직접 실행되는 형태로 사용되며, ISP(Internet Service Provider) 서비스 등을 위해서 사용 된다

### 6.1.2 프락시 vs 게이트웨이

- 프락시는 같은 프로토콜을 사용하는 어플리케이션을 연결, 게이트웨이는 서로 다른 프로토콜을 연결

![img.png](images/06_proxy_02.png)

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버는 보안 개선 / 성능 개선 / 비용 절약 등의 유용한 일을 한다
- 프락시 서버는 모든 HTTP 트래픽에 관여할 수 있기 때문에 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현 가능

#### 어린이 필터
- 어린이들에게 성인 컨텐츠를 차단하는 필터링 프락시

![img.png](images/06_proxy_03.png)

#### 문서 접근 제어자
- 웹 서버와 리소스에 대한 접근 제어를 중앙 프락시 서버를 통해 구현

![img.png](images/06_proxy_04.png)

#### 보안 방화벽
- 프락시 서버가 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 프락시 서버를 통해 한 지점에서 통제 가능

![img.png](images/06_proxy_05.png)

> 프락시를 통한 방화벽 개념과 서브넷을 활용한 물리적 분리 비교

> | 구분        | 프록시 서버를 통한 보안                       | 퍼블릭/프라이빗 서브넷 전략 (VPC)            |
> |:----------|:------------------------------------|:---------------------------------|
> | 주요 보호 계층  | 애플리케이션 계층 (L7)                      | 네트워크 계층 (L3/L4)                  |
> | 작동 위치     | 클라이언트와 서버 사이의 중개자                   | 클라우드 내 논리적 네트워크 경계               |
> | 보안 목표     | HTTP/HTTPS 요청 콘텐츠 검사 및 필터링, 익명성 제공  | 민감 자원(DB)의 인터넷 노출 원천 차단 및 격리     |
> | 주요 위협 대응  | 웹 애플리케이션 공격 (SQL 인젝션, XSS, 봇 트래픽)   | 무단 IP 접근, 포트 스캐닝, 인프라 침투         |
> | 보호 대상     | 요청/응답 데이터의 내용                       | 내부 서버의 IP 주소와 존재 자체              |
> | 예시 컴포넌트   | 리버스 프록시 (Nginx), WAF (웹 방화벽)        | VPC, 보안 그룹, 라우팅 테이블, NAT 게이트웨이   |

#### 웹 캐시
- 프락시 캐시는 인기 있는 문서의 로컬 사본을 관리하고, 해당 문서에 대한 요청을 빠르게 제공

![img.png](images/06_proxy_06.png)

> 웹 캐시와 CDN 의 차

> | 구분         | 웹 캐시 프록시 (Web Cache Proxy)          | CDN (Content Delivery Network)  |
> |:-----------|:------------------------------------|:--------------------------------|
> | **설치 목적**  | **네트워크 대역폭 절약** 및 내부망 접근 속도 개선      | 최종 사용자에게 **지연 시간(Latency) 최소화** |
> | **주요 사용자** | **내부 네트워크**의 클라이언트 그룹 (회사, ISP 가입자) | 전 세계 모든 **최종 사용자**              |
> | **위치/제어**  | 클라이언트 측 (사용 조직/ISP가 제어)             | 서버 측 (콘텐츠 제공자가 제어)              |
> | **캐시 방향**  | **Outbound** (외부 리소스를 내부망으로 당겨옴)    | **Inbound** (콘텐츠를 사용자에게 제공)     |
> | **분산 정도**  | 보통 **단일 지점** 또는 지역적                 | 전 세계 **수많은 엣지 서버(POP)**에 분산     |
> | **트래픽 절감** | 외부망으로 나가는 트래픽 비용 절감                 | 원본 서버(Origin)의 부하 절감            |

#### 대리 프락시(Surrogate)
- 웹 서버인 것 처럼 위장하는 기능을 통해 리버스 프락시라고 불리우며, 실제 웹 서버 요청을 받지만 요청 받은 컨텐츠의 처리는 다른 서버와 커뮤니케이션을 통해 처리 한다

> 포워드 프락시 vs 리버스 프록시 <br>
> 포워드 프록시 : 클라이언트(사용자)를 대신하여 외부에 요청. 내부망의 노출을 막고, 특정 사이트의에 대한 접근 제어, 캐싱을 통해 성능 개선 등을 목적
> 리버스 프록시 : 서버를 대신하여 클라이언트의 요청을 받음. 보안, 로드 밸런싱, 캐싱 등 서버 보호와 성능 최적화 목적 사용

```shell
# Upstream (백엔드 서버 그룹 정의)
upstream backend_servers {    
    # 로드 밸런싱 정책: 기본값 Round-Robin
    # weight=n: 가중치 설정 (이 서버가 n배 더 많은 트래픽 처리)
    # max_fails=3, fail_timeout=30s: 30초 동안 3번 실패하면 잠시 트래픽에서 제외
    server 192.168.1.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.1.11:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 192.168.1.12:8081;
}

# HTTP (80 포트) 설정: HTTPS로 강제 리다이렉션
server {
    listen 80;
    server_name www.우리가 사용할 도메인.com;
    
    # 301 Moved Permanently 코드로 모든 HTTP 요청을 HTTPS로 전환
    return 301 https://$host$request_uri;
}

# HTTPS (443 포트) 설정: SSL 종료 및 로드 밸런싱
server {
    # 443 포트로 수신하며 SSL/TLS 사용을 명시
    listen 443 ssl http2;
    server_name www.우리가 사용할 도메인.com;

    # 인증서 파일과 키를 통한 SSL/TLS 설정    
    ssl_certificate /etc/nginx/ssl/your_domain.crt;
    ssl_certificate_key /etc/nginx/ssl/your_domain.key;
    
    # 보안 강화를 위한 권장 프로토콜 및 암호화 설정
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5:!kEDH;
    ssl_prefer_server_ciphers on;    
    
    # 모든 요청(루트 요청, /)에 대한 프록시 설정
    location / {
        # upstream backend_servers 로 정의된 로드 밸런싱 그룹으로 전달
        proxy_pass http://backend_servers;

        # 필수 헤더 설정, 클라이언트의 실제 IP 주소 전달
        proxy_set_header X-Real-IP $remote_addr; 
        # 최초 요청 호스트명 전달
        proxy_set_header Host $host; 
        # NGINX가 SSL을 종료했음을 백엔드에 알림
        proxy_set_header X-Forwarded-Proto $scheme; 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Nginx 서버와 실제 어플리케이션 서버 사이의 내부 커넥션 유지 설정
        proxy_http_version 1.1; 
        proxy_set_header Connection ""; # 커넥션 헤더를 제거하여 내부 커넥션 재사용 유도
    }
}
```

#### 콘텐츠 라우터
- 트래픽의 조건과 콘텐츠의 종류에 따라 상황에 맞는 웹 서버로 트래픽을 유도하는 콘텐츠 라우터로 동작 가능

![img.png](images/06_proxy_07.png)

#### 트랜스코더
- 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정하는 프락시 서버
- 용량이 큰 이미지 포맷을 작은 이미지로 변환, 텍스트 압축, 언어 변환 등의 기능 제공

![img.png](images/06_proxy_08.png)

#### 익명화 프락시(Anonymizer)
- HTTP 메시지에서 신원을 특정할 수 있는 특성(IP 주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디 등)을 제거하여 익명성을 보장해 주는 프락시

![img.png](images/06_proxy_09.png)

## 6.3 프락시는 어디에 있는가?

### 6.3.1 프락시 서버 배치

#### 출구(Egress) 프락시
- 로컬 네트워크와 외부 인터넷 사이를 오가는 트래픽 제어를 위해 프락시를 로컬 네트워크 출구에 위치
- 방화벽 기능 및 어린이 필터, 성능 및 요금 절약의 용도로 사용

#### 접근(입구) 프락시
- 고객으로부터 모든 요청을 종합적으로 처리하기 위해 ISP 접근 지점에 위치
- 다룬로드 속도 개선 및 인터넷 대역폭 비용을 위해 캐시 프락시 사용 등

#### 대리 프락시
- 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 요청을 보내거나, 성능 개선등을 위해 사용

#### 네트워크 교환 프락시
- 캐시를 이용 인터넷 혼잡을 완화 및 트래픽 흐름을 감시하기 위한 프락시

![img.png](images/06_proxy_10.png)

### 6.3.2 프락시 계층

- 프락시들은 프락시 계층이라 불리는 연쇄 구성이 가능
- 프락시들은 부모와 자식 관계를 가지며, 서버에 가까운 쪽이 부모이며 클라이언트에 가까운 쪽이 자식이다

![img.png](images/06_proxy_11.png)

#### 프락시 계층 콘텐츠 라우팅
- 프락시 계층은 정적으로 구성되나, 요청 메시지에 의해서 다음 프락시 또는 원 서버등 유동적으로 처리가 가능하며 이를 `동적 부모 선택` 이라 한다
- 동적 부모 선택의 예
  - 부하 균형 : 자식 프락시는 원 서버의 부하 분산을 위해 현재 부모들의 작업량을 바탕으로 선택
  - 지리적 인접성에 근거한 라우팅 : 자신 프락시는 지역을 담당하는 부모를 선택
  - 프로토콜 / 타입 라우팅 : URI 에 따라 프락시를 선택
  - 유료 서비스 가입자를 위한 라우팅 : 비용 지불을 한 클라이언트에 한해서 성능 개선을 위한 캐시 프락시 등으로 선택

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

- 클라이언트 트래픽이 프락시로 가도록 만드는 방법은 아래의 4가지가 있다

#### 클라이언트를 수정한다
- 클라이언트가 프락시를 사용하도록 설정 되어있다면 클라이언트느 HTTP 요청을 바로 프락시로 보낸다

#### 네트워크를 수정한다
- 클라이언트가 아닌 네트워크 인프라를 가로채는 방법으로 트래픽을 프락시로 보내는 방법 (= 인터넷트 프락시)

#### DNS 이름 공간을 수정한다
- DNS 이름 테이블을 수동으로 편집하거나, 동적 DNS 서버를 이용하여 조절하여 모든 요청을 프락시 서버로 보내는 방법

#### 웹 서버를 수정한다
- 클라이언트 요청을 웹 서버에서 305 코드로 응답하여 프락시 서버로 리다이렉트 하는 방법

![img.png](images/06_proxy_12.png)

## 6.4 클라이언트 프락시 설정

#### 수동 설정
- 프락시를 사용하겠다고 명시적으로 설정

#### 브라우저 기본 설정
- 브라우저에서 프락시를 미리 설정하여 사용

#### 프락시 자동 설정(Proxy auto-configuration, PAC)
- JS 로 구성된 자동 설정(PAC) 파일에 대한 URI 를 제공하여, 클라리언트에게 언제 어떤 프락시를 쓸지 설정 가능

#### WPAD(Web Proxy Autodiscovery Protocol, WPAD) 프락시 발견
- 대부분의 브라우저는 자동 설정 파일을 다운 받을 수 있는 '설정 서버'를 자동으로 찾는 WPAD 를 제공

### 6.4.1 클라이언트 프락시 설정: 수동

- 많은 웹 클라이언트가 프락시를 수동으로 설정 가능. 요즘은 브라우저 별로 상이
  - OS 설정을 따라가는 브라우저 : 크롬 / 엣지 / 사파리
  - 자체 설정을 지원하는 브라우저 : 파이어폭스

### 6.4.2 클라리언트 프락시 설정: PAC 파일

- 수동 프락시는 유연하지 못하는 문제를 해결하기 위해 PAC 파일을 사용하여 브라우저에게 상황에 맞는 프락시를 설정할 수 있다

| FindProxyForURL 반환 값 | 설명               |
|:---------------------|:-----------------|
| DIRECT               | 프락시 없이 직접 연결     |
| PROXY host:port      | 지정한 프락시를 사용      |
| SOCKS host:port      | 지정한 SOCKS 서버를 사용 |

```js
function FindProxyForURL(url, host) {
    // 1. 내부 네트워크 주소는 프록시 사용 안 함 (Direct Access)    
    // isPlainHostName(): 호스트 이름에 점(.)이 없으면 내부망으로 간주 (예: http://intranet/)
    if (isPlainHostName(host)) {
        return "DIRECT";
    }
    
    // shExpMatch(): 와일드카드를 사용하여 내부망 IP 대역을 지정 (예: 192.168.x.x)
    // shExpMatch(str, shexp): 문자열(str)이 셸 표현식(shexp) 패턴과 일치하는지 확인
    if (shExpMatch(host, "192.168.*") || 
        shExpMatch(host, "10.0.0.*") || 
        shExpMatch(host, "*.local")) 
    {
        return "DIRECT";
    }    
    
    // 2. 특정 도메인에만 프록시 서버 사용    
    // dnsDomainIs(): 특정 도메인과 일치하는지 확인
    if (dnsDomainIs(host, ".external-service.com")) {        
        return "PROXY proxy.corp.com:8080";
    }    
    
    // 3. 보안(HTTPS) 트래픽과 일반 트래픽 분리    
    // url.substring(0, 5): URL의 시작 5글자를 확인 (https: 또는 http:)
    if (url.substring(0, 5) == "https") {
        // HTTPS 트래픽은 전용 프록시 사용 (보안 검사 목적)
        return "PROXY secure-proxy.corp.com:8443";
    }
    
    // 4. 모든 나머지 외부 요청 처리 (기본 규칙)    
    // 모든 HTTP 요청은 일반 프록시 서버를 통해 전송
    return "PROXY proxy.corp.com:8080; DIRECT";    
}
```

### 6.4.3 클라이언트 프락시 설정: WPAD

- WPAD 는 브라우저에 알맞은 PAC 파일을 자동으로 찾아 주는 알고리즘 (자세한 정보는 20장에서)