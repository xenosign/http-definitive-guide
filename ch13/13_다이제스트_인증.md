# 13. 다이제스트 인증

- 기본 인증은 편리하고 유연하지만 안전하게 이용하는 유일한 방법은 SSL 과 결합해서 사용하는 것

## 13.1 다이제스트 인증의 개선점

- 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 HTTP
- 다이제스트 인증의 특징
  - 비밀번호를 절대로 네트워크 상의 평문으로 전송하지 않음
  - 인증 체결을 가로채서 재현하려는 악의적인 시도를 차단
  - 구현에 따라 다르지만 메시지 내용 위조 방지 가능
  - 잘 알려진 형태의 공격을 막음
- 단, 다이제스트 인증이 가장 안전한 프로토콜은 아니며, 보안을 위해서는 전송 계층 보안(TLS)과 HTTPS 가 더 적합한 프로토콜이다
- 또한, 2000년대 초반에 대중화 시도가 있었으나 널리 사용은 안되었음

> 2000년대 중반 이후, HTTPS 의 보편화로 인하여 현재는 사용이 안되고 있음

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

- 다이제스트 인증의 좌우명, `절대로 비밀번호를 네트워크를 통해 보내지 않는다`
- 다이제스트 인증은 비밀번호를 보내는 대신 비밀번호를 비가역적으로 뒤섞은 `지문(fingerprint)` 혹은 `요약(digest)`를 보낸다
- 서버와 클라이언트는 원래 비밀번호를 아는 상태이므로 해당 비밀번호에 대응되는 지문 혹은 요약인지 검사가 가능

![img.png](images/13_digest_authentication_01.png)

### 13.1.2 단방향 요약

- 다이제스트 인증에서 사용하는 요약은 `정보 본문의 압축` 이며, 단방향 함수이며 무한의 입력값을 유한한 범위의 압축으로 변환하여 처리한다
- 주료 사용되는 `MD5` 는 임의의 바이트 배열을 원래 길이와 상관 없이 128 비트 요약으로 변환
  - 128 비트를 사용하므로 2 ^ 128 = 3.403 x 10 ^ 38 수의 다른 압축이 가능
- 따라서 원문을 모를 경우 해당 수 만큼의 반복을 통해 해당 원문을 알아내야 하므로, 중요 정보를 평문으로 그대로 보내는 보안적 문제를 보완 

> MD5(Message-Digest Algorithm 5) 는 1991년 로널드 라이베스트에 의해서 개발
> - 입력 메시지의 길이를 512 비트의 배수가 되도록 패딩하고, 각각 512 비트의 메시지를 초기화 버퍼와 4개의 라운드(16번의 연산)를 거쳐서 변환
> - 최종적으로 4개의 32 비트 레지스터에 남은 값을 128 비트 해시 값으로 압축하여 출력하는 알고리즘
> - 하지만, 입력 가능한 데이터는 무한하지만 압축된 결과는  3.403 x 10 ^ 38 개라는 한계가 존재하여 서로 다른 값이지만 동일한 압축 값을 가질 수 있는 비둘기 집 원리에 의한 충돌 위험성이 존재
> - 실제로 충돌 공격에 의한 위험성이 입증되어 현재는 보안의 목적으로 사용되지 않음

> 현재의 암호화 전략
> - 128 비트보다 더 많은 수를 압축이 가능한 SHA-1(160 비트), SHA-256(256 비트), SHA-512(512 비트)를 알고리즘을 사용. 또한, SHA 의 경우 MD 보다 복잡하고 안전한 내부 구조를 가짐
> - 단, SHA-1 의 경우 2017 년에 충돌이 발견되어 공식적으로 종료. 이를, 해결하고자 SHA-2(256, 512)가 개발
> - 결국 SHA 도 비밀 키를 사용하지 않으므로 충돌 공격에 따른 위험성이 있으므로, 송신자와 수신자만이 공유하는 비밀 키를 사용하는 HMAC(Hash-Based Message Authentication Code) 를 사용
> - 현재는 HMAC 내부에 SHA-256 을 사용하는 HMAC-SHA256 이 표준적으로 사용


### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

- 비밀번호를 암호화 하여 전달하여도 공격자에 의해 요청 또는 요약이 탈취 당하는 경우, 비밀번호 자체를 탈취 당하는 것과 다름이 없으므로 이에 대한 보완이 필요
- 이러한 탈취와 재전송 공격을 방지하기 위해서 서버에서는 `난스`라고 불리는 일회용 증표를 클라이언트에 전달. 서버는 요청의 난스를 비교하여 요청이 적합성을 판단
  - 난스는 만료 시간(약한 보안) 또는 사용 여부 확인(강한 보안)에 따라 적합성을 판단 
- `난스`는 WWW-Authenticate 인증 요구에 담겨서 서버에서 클라이언트로 넘겨진다

### 13.1.4 다이제스트 인증 핸드셰이크

- HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 헤더에 몇몇 새 옵션이 추가되었으며, 선택 헤더인 `Authorization-info` 가 추가된 강화 버전의 인증이다

![img.png](images/13_digest_authentication_02.png)

- 기본 인증과 다이제스트 인증 과정 비교

![img.png](images/13_digest_authentication_03.png)

![img_1.png](images/13_digest_authentication_04.png)

> 과정의 Step 은 동일하나, 서버와 클라이언트간의 `난스` 확인 작업과, 비밀번호 등이 암호화되어 요약으로 전달(암호화된 문자열, 암호화 알고리즘 등)되는 것에 차이가 존재

## 13.2 요약 계산

- 다이제스트 인증은 단방향 요약 메세지가 핵심이며, 해당 요약에는 공개된 정보, 비밀 정보, 시한부 난스 값을 조합하여 계산

### 13.2.1 요약 알고리즘 입력 데이터

- 요약은 다음의 세 요소로 부터 계산
- 단방향 해시 함수 H(d) 와 요약 함수 KD(s, d) 이며, s 는 비밀(secret)을 d 는 데이터(data) 를 의미
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리는 A1 이라 칭한다
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리는 A2 라 칭한다

### 13.2.2 H(d) 와 KD(s, d) 알고리즘

- 다이제스트 인증은 여러가지 요약 알고리즘이 선택 가능하며, RFC 2617 에서 제안된 두 알고리즘은 MD5 와 MD5-sess(ion) 이며 기본은 MD5
- 요약은 아래의 식에 의하여 계산 된다

```
H(<데이터>) = MD5(<데이터>)
KD(<비밀>, <데이터>) = H(연결(<비밀>:<데이터>))
```

### 13.2.3 보안 관련 데이터 (A1)

- A1 이라 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 구성
- RFC 2617 은 A1 을 계산할 수 있는 2가지 알고리즘을 정의

#### MD5
- 모든 요청마다 단방향 해시를 실행
- `A1 = <사용자>:<영억>:<비밀번호>`

#### MD5-sess
- 사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트의 난스(c난스)를 붙인 것이 A1 이 되는 알고리즘
- 계산에 CPU 가 많이 사용되는 만큼 WWW-Authenticate 핸드셰이크를 할 때 한 번만 수행
- `A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>`

### 13.2.4 메시지 관련 데이터 (A2)

- A2 로 불리는 데이터 덩이러는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보로 구성
- 메시지 위조를 방지하기 위해 사용
- RFC 2617 에 의해 2 가지 사용법이 정의
  - HTTP 요청 메서드와 URL 만 포함. `qop = "auth"` 일 때 사용
  - 메시지 무결성 검사를 위해 엔터티 본문까지 A2 에 추가, `qop = "auth-int"` 일 때 사용

![img.png](images/13_digest_authentication_05.png)

### 13.2.5 요약 알고리즘 전반

- RFC 2617 은 주어진 H, KD, A1, A2 러 요약을 계산하는 2 가지 방법 정의
- 첫번째 방법, 이전 명세인 RFC 2069 과 호환을 위해, qop 옵션이 빠졌을 때 사용. 단, 없어질 예정  
- 두번째 방법, 현대적인 방법으로 난스 횟수 집계 및 대칭 인증 지원을 포함. qop 가 'auth', 'auth-int' 일 때 모두 사용

![img_1.png](images/13_digest_authentication_06.png)

- 요약 알고리즘을 더 펼친 버전의 표

![img.png](images/13_digest_authentication_07.png)

### 13.2.6 다이제스트 인증 세션

- WWW-Authenticate 인증 요구에 대해서 클라이언트는 인증 세션으로 응답을 하게되며, 다른 서버로 부터 또 다른 WWW-Authenticate 를 받을 때까지 지속
- 클라이언트가 인증을 위한 Authorization 헤더를 다시 만들기 위해 사용자 이름, 비밀번호, 난스, 난스 횟수를 기억해야 한다
- 또한, 서버는 낡은 난스 값을 감수하고 Authorization 헤더 정보 값을 받거나 새로운 난스 값과 함께 401 응답을 반환할 수 있다. 혹은, `stale=true` 로 정의하여 새롭게 인증 세션을 열지않고 새로운 난스 값으로 다시 요청을 보내라고 할 수 있다

### 13.2.7 사전(preemptive) 인가

- 클라이언트가 다음 난스를 미리 알고, 올바른 Authorization 헤더를 생성할 수 있다면 요청/인증요구 사이클을 줄일 수 있으며, 이를 사전 인가라 한다

![img.png](images/13_digest_authentication_08.png)

- 다이제스트 인증의 경우 재전송 공격을 막기 위해 난스를 포함한 인증 과정을 거치므로 사전 인가가 더 복잡해진다
- 다이제스트의 안전한 기능을 유지하면서 WWW-Authenticate 인증 요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법이 존재

#### 다음 난스 미리 생성하기

- 서버에서 미리 다음 난스를 생성하여 Authentication-info 헤더에 다음 난스 값을 미리 제공하여, 클라이언트가 WWW-Authenticate 인증 요구없이 Authorization 를 헤더를 생성하는 방법
- 요청과 응답에 대한 커넥션을 계속 새롭게 만드는 기존 방식에 대해서는 유효하지만, 다중 요청을 연결을 유지한 상태로 지속 전달하는 파이프라이닝에는 실질적으로 쓸모가 없어지는 방법

#### 제한된 난스 재사용

- 연속된 난스를 계속 만드는 것이 아니라, 난스에 지속시간을 도입하여 일정 시간(ex. 10초) 재사용하도록 하는 방법
- 클라이언트는 이전에 받은 난스를 통해 자유롭게 Authorization 헤더 생성이 가능하므로, 요청을 파이프라이닝 처리가 가능
- 지속 시간이 만료 되면 서버는 401 Unauthorized 인증 요구(stale 옵션을 true 로 전달)를 보내고 다시 난스를 주고 받는 작업을 반복
- 단, 난스의 재사용으로 인해 재전송 공격에 취약한 문제가 발생

#### 동기화된 난스 생성

- 공유된 비밀키에 기반하여 클라이언트와 서버가 순차적으로 동일한 난스를 생성할 수 있는 동기화를 사용하는 방법
- 단, 해당 방법은 다이제스트 인증의 범위를 넘어서는 기술

### 13.2.8 난스 선택

- 난스의 내용은 불투명하고 각각의 구현에 의존적이나 성능과 보안, 편의성에 대한 고려가 필요
- RFC 2617 는 `BASE64(타임스탬프 H(타임스탬프 ":" ETag ":" 개인키))` 라는 난스 공식을 제안
  - 타임 스탬프는 요청이 오래된 경우 거절이 가능하며, 난스의 유효 기간을 지정이 가능
  - ETag 는 요청된 엔터티에 대한 ETag 값으로 갱신 된 리소스에 대한 재요청을 방지
  - 개인키는 요청이 탈취 된 경우, 암호 복호화를 막기 위한 용도

### 13.2.9 상호 인증

- 클라이언트가 서버를 인증할 수 있도록 RFC 2617 에서 확장된 기능으로, 클라이언트와 서버가 공유된 비밀 정보에 근거하여 올바른 응답 요약을 생성할 수 있도록 클라이언트 난스(c난스) 값을 제공
- 요청 알고리즘과 마찬가지로 RFC 2069 와의 하위 호환성을 고려하여 qop 지시자에 의해 수행을 결정. 단, 응답이기 때문에 HTTP 메서드가 존재하지 않음

![img.png](images/13_digest_authentication_09.png)